# 数据区子包恢复功能实现方案

## 1. 概述

本文档详细描述了APDL框架中数据区子包恢复功能的实现方案，包括独立的字段映射机制（连接器模式）和基于导头指针的子包处理机制。

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    APDL Framework                     │
├─────────────────────────────────────────────────────────┤
│  DSL Parser          │  Protocol Engine               │
│  ┌─────────────────┐ │  ┌──────────────────────────┐  │
│  │ Package Def.    │ │  │ Nested Packet Recovery   │  │
│  │ Handler         │ │  │ Engine                   │  │
│  └─────────────────┘ │  │                          │  │
│  ┌─────────────────┐ │  │  ┌─────────────────────┐ │  │
│  │ Mapping Rule    │ │  │  │ Field Mapping       │ │  │
│  │ Handler         │ │  │  │ Connector           │ │  │
│  └─────────────────┘ │  │  └─────────────────────┘ │  │
│  ┌─────────────────┐ │  │  ┌─────────────────────┐ │  │
│  │ Header Pointer  │ │  │  │ Header Pointer      │ │  │
│  │ Handler         │ │  │  │ Resolver            │ │  │
│  └─────────────────┘ │  │  └─────────────────────┘ │  │
│                       │  │  ┌─────────────────────┐ │  │
│                       │  │  │ Nested Packet       │ │  │
│                       │  │  │ Boundary Detector   │ │  │
│                       │  │  └─────────────────────┘ │  │
│                       │  │  ┌─────────────────────┐ │  │
│                       │  │  │ Stream Injection &  │ │  │
│                       │  │  │ Recovery Module     │ │  │
│                       │  │  └─────────────────────┘ │  │
│                       │  └──────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 2.2 核心模块设计

#### 2.2.1 包定义处理器（Package Definition Processor）

职责：
- 解析独立的包定义
- 维护包的结构信息
- 提供包间引用能力

接口设计：
```rust
trait PackageDefinitionProcessor {
    fn parse_package_definition(&self, package_def: PackageDefinition) -> Result<ParsedPackage, ParseError>;
    fn get_package_fields(&self, package_name: &str) -> Option<&Vec<FieldDefinition>>;
    fn validate_package_structure(&self, package: &ParsedPackage) -> Result<(), ValidationError>;
}
```

#### 2.2.2 字段映射连接器（Field Mapping Connector）

职责：
- 实现独立的字段映射规则
- 执行下层包到上层包的字段映射
- 管理映射逻辑和默认值

接口设计：
```rust
trait FieldMappingConnector {
    fn apply_mapping(
        &self, 
        source_package: &ParsedPackage, 
        target_package: &mut ParsedPackage
    ) -> Result<(), MappingError>;
    
    fn resolve_field_mapping(
        &self, 
        source_value: &[u8], 
        mapping_rule: &FieldMappingRule
    ) -> Result<Vec<u8>, MappingError>;
    
    fn validate_mapping_rules(&self, rules: &[FieldMappingRule]) -> Result<(), ValidationError>;
}
```

#### 2.2.3 导头指针解析器（Header Pointer Resolver）

职责：
- 解析主/副导头指针字段
- 计算下层包在数据区中的实际位置
- 验证指针的有效性

接口设计：
```rust
trait HeaderPointerResolver {
    fn resolve_master_pointer(&self, pointer_value: u16, data_area_base: usize) -> Result<usize, ResolutionError>;
    fn resolve_secondary_pointers(&self, pointers: &[u16], data_area_base: usize) -> Result<Vec<usize>, ResolutionError>;
    fn validate_pointer_range(&self, pointer: u16, data_area_size: usize) -> bool;
}
```

#### 2.2.4 嵌套包边界检测器（Nested Packet Boundary Detector）

职责：
- 根据嵌套包描述符检测数据区中的包边界
- 生成包分段信息
- 验证包完整性

接口设计：
```rust
trait NestedPacketBoundaryDetector {
    fn detect_boundaries(&self, descriptors: &[NestedPacketDescriptor], data: &[u8]) -> Result<Vec<NestedPacketSegment>, DetectionError>;
    fn validate_segment_integrity(&self, segment: &NestedPacketSegment) -> Result<bool, ValidationError>;
    fn reconstruct_nested_packets(&self, segments: Vec<NestedPacketSegment>) -> Result<Vec<NestedPacket>, ReconstructionError>;
}
```

#### 2.2.5 数据流注入与恢复模块（Stream Injection & Recovery Module）

职责：
- 将具有完整帧定义的下层包注入到数据区
- 从数据区恢复原始下层包流
- 处理数据对齐和边界标记

接口设计：
```rust
trait StreamProcessor {
    fn inject_nested_packets(&self, packets: &[NestedPacket], target_area: &mut [u8]) -> Result<InjectionResult, InjectionError>;
    fn recover_nested_packets(&self, data_area: &[u8], descriptors: &[NestedPacketDescriptor]) -> Result<Vec<NestedPacket>, RecoveryError>;
    fn align_data(&self, data: &[u8], alignment: usize) -> Vec<u8>;
}
```

## 3. 实现细节

### 3.1 包定义结构

#### 3.1.1 包定义模型

```rust
#[derive(Debug, Clone)]
pub struct PackageDefinition {
    pub name: String,
    pub layers: Vec<LayerDefinition>,
    pub metadata: PackageMetadata,
}

#[derive(Debug, Clone)]
pub struct LayerDefinition {
    pub name: String,
    pub units: Vec<FieldDefinition>,
}

#[derive(Debug, Clone)]
pub struct FieldDefinition {
    pub field_id: String,
    pub field_type: FieldType,
    pub length: FieldLength,
    pub description: String,
    pub role: String,
    pub constraint: Option<FieldConstraint>,
}

#[derive(Debug, Clone)]
pub enum FieldType {
    Bit(u8),
    Uint8,
    Uint16,
    Uint32,
    Uint64,
    RawData,
    Array(Box<FieldType>),
    Struct(HashMap<String, FieldType>),
}

#[derive(Debug, Clone)]
pub enum FieldLength {
    Fixed(usize),
    Dynamic,
    Variable,
}
```

#### 3.1.2 包定义处理器实现

```rust
pub struct PackageDefinitionProcessorImpl {
    packages: HashMap<String, ParsedPackage>,
}

impl PackageDefinitionProcessor for PackageDefinitionProcessorImpl {
    fn parse_package_definition(&self, package_def: PackageDefinition) -> Result<ParsedPackage, ParseError> {
        let mut parsed_layers = Vec::new();
        
        for layer_def in package_def.layers {
            let mut parsed_units = Vec::new();
            
            for field_def in layer_def.units {
                let parsed_field = ParsedField {
                    id: field_def.field_id.clone(),
                    field_type: field_def.field_type.clone(),
                    length: field_def.length.clone(),
                    position: None, // 位置将在组帧时确定
                    value: None,    // 值将在运行时设置
                };
                
                parsed_units.push(parsed_field);
            }
            
            let parsed_layer = ParsedLayer {
                name: layer_def.name,
                units: parsed_units,
            };
            
            parsed_layers.push(parsed_layer);
        }
        
        Ok(ParsedPackage {
            name: package_def.name,
            layers: parsed_layers,
            metadata: package_def.metadata,
        })
    }
    
    fn get_package_fields(&self, package_name: &str) -> Option<&Vec<FieldDefinition>> {
        self.packages.get(package_name).map(|pkg| &pkg.fields)
    }
    
    fn validate_package_structure(&self, package: &ParsedPackage) -> Result<(), ValidationError> {
        // 验证包结构的完整性
        if package.layers.is_empty() {
            return Err(ValidationError::EmptyPackage);
        }
        
        for layer in &package.layers {
            if layer.units.is_empty() {
                return Err(ValidationError::EmptyLayer(layer.name.clone()));
            }
        }
        
        Ok(())
    }
}
```

### 3.2 字段映射连接器实现

#### 3.2.1 映射规则定义

```rust
#[derive(Debug, Clone)]
pub struct FieldMappingRule {
    pub source_field: String,        // 源字段名
    pub target_field: String,        // 目标字段名
    pub mapping_logic: MappingLogic,  // 映射逻辑
    pub default_value: Vec<u8>,      // 默认值
}

#[derive(Debug, Clone)]
pub enum MappingLogic {
    Hash { divisor: u64 },          // 哈希映射
    Identity,                       // 直接映射
    Formula(String),                // 公式映射
    Lookup(HashMap<Vec<u8>, Vec<u8>>), // 查找表映射
}
```

#### 3.2.2 字段映射连接器实现

```rust
pub struct FieldMappingConnectorImpl {
    mapping_rules: Vec<FieldMappingRule>,
}

impl FieldMappingConnector for FieldMappingConnectorImpl {
    fn apply_mapping(
        &self, 
        source_package: &ParsedPackage, 
        target_package: &mut ParsedPackage
    ) -> Result<(), MappingError> {
        for rule in &self.mapping_rules {
            // 获取源字段值
            let source_value = self.extract_source_value(source_package, &rule.source_field)?;
            
            // 应用映射逻辑
            let mapped_value = self.resolve_field_mapping(&source_value, rule)?;
            
            // 设置目标字段值
            self.set_target_value(target_package, &rule.target_field, mapped_value)?;
        }
        
        Ok(())
    }
    
    fn resolve_field_mapping(
        &self, 
        source_value: &[u8], 
        mapping_rule: &FieldMappingRule
    ) -> Result<Vec<u8>, MappingError> {
        match &mapping_rule.mapping_logic {
            MappingLogic::Identity => Ok(source_value.to_vec()),
            
            MappingLogic::Hash { divisor } => {
                let hash_value = self.calculate_hash(source_value);
                let result = (hash_value % divisor) as u64;
                
                // 将结果转换为目标字段所需的字节数
                Ok(result.to_le_bytes()[..std::mem::size_of::<u64>()].to_vec())
            },
            
            MappingLogic::Formula(formula) => {
                self.evaluate_formula(formula, source_value)
            },
            
            MappingLogic::Lookup(lookup_table) => {
                lookup_table.get(source_value)
                    .cloned()
                    .ok_or_else(|| MappingError::MappingNotFound(source_value.to_vec()))
            }
        }
    }
    
    fn validate_mapping_rules(&self, rules: &[FieldMappingRule]) -> Result<(), ValidationError> {
        // 验证映射规则的有效性
        for rule in rules {
            if rule.source_field.is_empty() || rule.target_field.is_empty() {
                return Err(ValidationError::InvalidMappingRule(rule.clone()));
            }
        }
        
        Ok(())
    }
}

impl FieldMappingConnectorImpl {
    fn extract_source_value(&self, source_package: &ParsedPackage, field_name: &str) -> Result<Vec<u8>, MappingError> {
        for layer in &source_package.layers {
            for unit in &layer.units {
                if unit.id == field_name {
                    if let Some(ref value) = unit.value {
                        return Ok(value.clone());
                    } else {
                        return Err(MappingError::SourceFieldNotSet(field_name.to_string()));
                    }
                }
            }
        }
        
        Err(MappingError::SourceFieldNotFound(field_name.to_string()))
    }
    
    fn set_target_value(&self, target_package: &mut ParsedPackage, field_name: &str, value: Vec<u8>) -> Result<(), MappingError> {
        for layer in &mut target_package.layers {
            for unit in &mut layer.units {
                if unit.id == field_name {
                    unit.value = Some(value);
                    return Ok(());
                }
            }
        }
        
        Err(MappingError::TargetFieldNotFound(field_name.to_string()))
    }
    
    fn calculate_hash(&self, data: &[u8]) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        data.hash(&mut hasher);
        hasher.finish()
    }
    
    fn evaluate_formula(&self, formula: &str, source_value: &[u8]) -> Result<Vec<u8>, MappingError> {
        // 简化的公式评估实现
        // 实际实现中可能需要集成一个表达式解析器
        match formula.as_str() {
            "hash(x) % 64" => {
                let hash_value = self.calculate_hash(source_value);
                let result = (hash_value % 64) as u8;
                Ok(vec![result])
            },
            _ => Err(MappingError::UnsupportedFormula(formula.to_string())),
        }
    }
}
```

### 3.3 导头指针解析实现

#### 3.3.1 指针解析器实现

```rust
pub struct HeaderPointerResolverImpl {
    max_data_area_size: usize,
    min_pointer_value: u16,
    max_pointer_value: u16,
}

impl HeaderPointerResolver for HeaderPointerResolverImpl {
    fn resolve_master_pointer(&self, pointer_value: u16, data_area_base: usize) -> Result<usize, ResolutionError> {
        if !self.validate_pointer_range(pointer_value, self.max_data_area_size) {
            return Err(ResolutionError::InvalidPointer(pointer_value));
        }

        Ok(data_area_base + pointer_value as usize)
    }

    fn resolve_secondary_pointers(&self, pointers: &[u16], data_area_base: usize) -> Result<Vec<usize>, ResolutionError> {
        let mut resolved_addresses = Vec::new();
        
        for &pointer in pointers {
            if !self.validate_pointer_range(pointer, self.max_data_area_size) {
                return Err(ResolutionError::InvalidPointer(pointer));
            }
            
            resolved_addresses.push(data_area_base + pointer as usize);
        }

        Ok(resolved_addresses)
    }

    fn validate_pointer_range(&self, pointer: u16, data_area_size: usize) -> bool {
        (self.min_pointer_value..=self.max_pointer_value).contains(&pointer) && 
        (pointer as usize) < data_area_size
    }
}
```

### 3.4 嵌套包边界检测实现

#### 3.4.1 嵌套包描述符结构

```rust
#[derive(Debug, Clone)]
pub struct NestedPacketDescriptor {
    pub offset: u16,      // 在数据区中的偏移
    pub length: u16,      // 包长度
    pub packet_type: u8,  // 包类型
    pub flags: u8,        // 标志位
}

#[derive(Debug)]
pub struct NestedPacketSegment {
    pub data: Vec<u8>,
    pub descriptor: NestedPacketDescriptor,
    pub start_position: usize,
    pub end_position: usize,
}
```

#### 3.4.2 边界检测器实现

```rust
pub struct NestedPacketBoundaryDetectorImpl {
    max_packet_size: usize,
    min_packet_size: usize,
}

impl NestedPacketBoundaryDetector for NestedPacketBoundaryDetectorImpl {
    fn detect_boundaries(&self, descriptors: &[NestedPacketDescriptor], data: &[u8]) -> Result<Vec<NestedPacketSegment>, DetectionError> {
        let mut segments = Vec::new();

        for descriptor in descriptors {
            // 验证描述符的有效性
            if descriptor.offset as usize >= data.len() || 
               (descriptor.offset as usize + descriptor.length as usize) > data.len() {
                return Err(DetectionError::InvalidDescriptor(descriptor.clone()));
            }

            // 提取包数据
            let start = descriptor.offset as usize;
            let end = start + descriptor.length as usize;
            let packet_data = data[start..end].to_vec();

            let segment = NestedPacketSegment {
                data: packet_data,
                descriptor: descriptor.clone(),
                start_position: start,
                end_position: end,
            };

            segments.push(segment);
        }

        // 验证段之间是否有重叠
        self.validate_no_overlap(&segments)?;

        Ok(segments)
    }

    fn validate_segment_integrity(&self, segment: &NestedPacketSegment) -> Result<bool, ValidationError> {
        // 检查数据长度是否与描述符匹配
        if segment.data.len() != segment.descriptor.length as usize {
            return Ok(false);
        }

        // 可以添加更多完整性检查，如校验和验证等
        Ok(true)
    }

    fn reconstruct_nested_packets(&self, segments: Vec<NestedPacketSegment>) -> Result<Vec<NestedPacket>, ReconstructionError> {
        let mut packets = Vec::new();

        for segment in segments {
            let packet = NestedPacket {
                data: segment.data,
                packet_type: segment.descriptor.packet_type,
                flags: segment.descriptor.flags,
                metadata: PacketMetadata {
                    original_position: segment.start_position,
                    reconstructed_at: std::time::SystemTime::now(),
                },
            };

            packets.push(packet);
        }

        Ok(packets)
    }
}

impl NestedPacketBoundaryDetectorImpl {
    fn validate_no_overlap(&self, segments: &[NestedPacketSegment]) -> Result<(), DetectionError> {
        let mut sorted_segments = segments.to_vec();
        sorted_segments.sort_by_key(|s| s.start_position);
        
        for i in 1..sorted_segments.len() {
            if sorted_segments[i-1].end_position > sorted_segments[i].start_position {
                return Err(DetectionError::OverlappingSegments(
                    sorted_segments[i-1].start_position,
                    sorted_segments[i].start_position
                ));
            }
        }
        
        Ok(())
    }
}
```

### 3.5 数据流注入与恢复实现

#### 3.5.1 数据流处理器

```rust
pub struct StreamProcessorImpl {
    alignment: usize,
    boundary_marker: Option<u8>,
}

impl StreamProcessor for StreamProcessorImpl {
    fn inject_nested_packets(&self, packets: &[NestedPacket], target_area: &mut [u8]) -> Result<InjectionResult, InjectionError> {
        let mut current_offset = 0;
        let mut descriptors = Vec::new();
        let mut used_space = 0;

        for (index, packet) in packets.iter().enumerate() {
            // 计算所需空间（包括可能的对齐填充）
            let aligned_offset = self.align_offset(current_offset, self.alignment);
            let required_space = packet.data.len();
            
            if aligned_offset + required_space > target_area.len() {
                return Err(InjectionError::InsufficientSpace {
                    required: required_space,
                    available: target_area.len() - aligned_offset,
                });
            }

            // 写入包数据
            let start_pos = aligned_offset;
            let end_pos = start_pos + required_space;
            target_area[start_pos..end_pos].copy_from_slice(&packet.data);

            // 创建描述符
            let descriptor = NestedPacketDescriptor {
                offset: aligned_offset as u16,
                length: required_space as u16,
                packet_type: packet.packet_type,
                flags: packet.flags,
            };

            descriptors.push(descriptor);
            current_offset = end_pos;
            used_space += required_space;
        }

        Ok(InjectionResult {
            descriptors,
            used_space,
            alignment_padding: current_offset - used_space,
        })
    }

    fn recover_nested_packets(&self, data_area: &[u8], descriptors: &[NestedPacketDescriptor]) -> Result<Vec<NestedPacket>, RecoveryError> {
        let mut recovered_packets = Vec::new();

        for descriptor in descriptors {
            if descriptor.offset as usize >= data_area.len() ||
               (descriptor.offset as usize + descriptor.length as usize) > data_area.len() {
                return Err(RecoveryError::InvalidDescriptor(descriptor.clone()));
            }

            let start = descriptor.offset as usize;
            let end = start + descriptor.length as usize;
            let packet_data = data_area[start..end].to_vec();

            let packet = NestedPacket {
                data: packet_data,
                packet_type: descriptor.packet_type,
                flags: descriptor.flags,
                metadata: PacketMetadata {
                    original_position: start,
                    reconstructed_at: std::time::SystemTime::now(),
                },
            };

            recovered_packets.push(packet);
        }

        Ok(recovered_packets)
    }

    fn align_data(&self, data: &[u8], alignment: usize) -> Vec<u8> {
        let remainder = data.len() % alignment;
        if remainder == 0 {
            data.to_vec()
        } else {
            let padding_needed = alignment - remainder;
            let mut aligned_data = data.to_vec();
            aligned_data.extend(vec![0u8; padding_needed]);
            aligned_data
        }
    }
}

impl StreamProcessorImpl {
    fn align_offset(&self, offset: usize, alignment: usize) -> usize {
        if alignment <= 1 {
            return offset;
        }
        
        let remainder = offset % alignment;
        if remainder == 0 {
            offset
        } else {
            offset + (alignment - remainder)
        }
    }
}
```

## 4. 集成实现

### 4.1 嵌套包恢复引擎

```rust
pub struct NestedPacketRecoveryEngine {
    package_processor: Box<dyn PackageDefinitionProcessor>,
    field_mapper: Box<dyn FieldMappingConnector>,
    pointer_resolver: Box<dyn HeaderPointerResolver>,
    boundary_detector: Box<dyn NestedPacketBoundaryDetector>,
    stream_processor: Box<dyn StreamProcessor>,
}

impl NestedPacketRecoveryEngine {
    pub fn new(
        package_processor: Box<dyn PackageDefinitionProcessor>,
        field_mapper: Box<dyn FieldMappingConnector>,
        pointer_resolver: Box<dyn HeaderPointerResolver>,
        boundary_detector: Box<dyn NestedPacketBoundaryDetector>,
        stream_processor: Box<dyn StreamProcessor>,
    ) -> Self {
        Self {
            package_processor,
            field_mapper,
            pointer_resolver,
            boundary_detector,
            stream_processor,
        }
    }

    pub fn process_nested_packet(&self, 
        lower_package: &ParsedPackage, 
        upper_package_template: &mut ParsedPackage,
        mapping_rules: &[FieldMappingRule]
    ) -> Result<ProcessedPacket, ProcessingError> {
        // 1. 应用字段映射规则
        let mut mapped_upper_package = upper_package_template.clone();
        self.field_mapper.apply_mapping(lower_package, &mut mapped_upper_package)?;
        
        // 2. 将下层包数据注入上层包数据区
        let lower_package_data = self.serialize_package(lower_package)?;
        let mut upper_data_area = vec![0u8; 1024]; // 预分配数据区
        
        // 3. 获取上层包的数据字段位置
        let data_field_pos = self.find_data_field_position(&mapped_upper_package)?;
        
        // 4. 将下层包数据注入上层包的数据区
        self.stream_processor.inject_nested_packets(
            &[NestedPacket {
                data: lower_package_data,
                packet_type: 0,
                flags: 0,
                metadata: PacketMetadata {
                    original_position: 0,
                    reconstructed_at: std::time::SystemTime::now(),
                },
            }],
            &mut upper_data_area
        )?;
        
        // 5. 更新上层包的数据字段
        self.update_data_field(&mut mapped_upper_package, data_field_pos, &upper_data_area)?;
        
        Ok(ProcessedPacket {
            package: mapped_upper_package,
            metadata: ProcessingMetadata::default(),
        })
    }

    pub fn recover_nested_packets(&self, 
        encapsulated_package: &ParsedPackage
    ) -> Result<Vec<ParsedPackage>, RecoveryError> {
        // 1. 从封装包中提取数据区
        let data_area = self.extract_data_area(encapsulated_package)?;
        
        // 2. 解析导头指针
        let descriptors = self.parse_header_pointers(encapsulated_package)?;
        
        // 3. 恢复嵌套包
        let recovered_packets = self.stream_processor.recover_nested_packets(data_area, &descriptors)?;
        
        // 4. 将恢复的包转换为ParsedPackage格式
        let mut parsed_packages = Vec::new();
        for packet in recovered_packets {
            let parsed = self.deserialize_package(&packet.data)?;
            parsed_packages.push(parsed);
        }
        
        Ok(parsed_packages)
    }

    fn serialize_package(&self, package: &ParsedPackage) -> Result<Vec<u8>, SerializationError> {
        // 序列化包为字节流的实现
        let mut result = Vec::new();
        
        for layer in &package.layers {
            for unit in &layer.units {
                if let Some(ref value) = unit.value {
                    result.extend_from_slice(value);
                }
            }
        }
        
        Ok(result)
    }

    fn deserialize_package(&self, data: &[u8]) -> Result<ParsedPackage, DeserializationError> {
        // 从字节流反序列化包的实现
        // 这里需要根据具体的包定义进行反序列化
        unimplemented!("Package deserialization needs to be implemented based on specific package definition")
    }
    
    fn find_data_field_position(&self, package: &ParsedPackage) -> Result<usize, ProcessingError> {
        // 查找数据字段在包中的位置
        let mut position = 0;
        for layer in &package.layers {
            for unit in &layer.units {
                if unit.id.contains("data") || unit.id.contains("payload") {
                    return Ok(position);
                }
                position += unit.length.get_size();
            }
        }
        Err(ProcessingError::DataFieldNotFound)
    }
    
    fn update_data_field(&self, package: &mut ParsedPackage, position: usize, data: &[u8]) -> Result<(), ProcessingError> {
        // 更新数据字段的实现
        for layer in &mut package.layers {
            for unit in &mut layer.units {
                if unit.id.contains("data") || unit.id.contains("payload") {
                    unit.value = Some(data.to_vec());
                    break;
                }
            }
        }
        Ok(())
    }
    
    fn extract_data_area(&self, package: &ParsedPackage) -> Result<&[u8], RecoveryError> {
        // 从封装包中提取数据区的实现
        for layer in &package.layers {
            for unit in &layer.units {
                if unit.id.contains("data") || unit.id.contains("payload") {
                    if let Some(ref value) = unit.value {
                        return Ok(value);
                    }
                }
            }
        }
        Err(RecoveryError::DataAreaNotFound)
    }
    
    fn parse_header_pointers(&self, package: &ParsedPackage) -> Result<Vec<NestedPacketDescriptor>, RecoveryError> {
        // 解析导头指针的实现
        let mut descriptors = Vec::new();
        
        for layer in &package.layers {
            for unit in &layer.units {
                if unit.id.contains("pointer") {
                    // 解析指针字段并创建描述符
                    // 这里需要根据具体的指针格式进行解析
                    continue;
                }
            }
        }
        
        Ok(descriptors)
    }
}

#[derive(Debug)]
pub struct ProcessedPacket {
    pub package: ParsedPackage,
    pub metadata: ProcessingMetadata,
}

#[derive(Debug, Default)]
pub struct ProcessingMetadata {
    pub processing_time: std::time::SystemTime,
    pub original_size: usize,
    pub compressed_size: usize,
}

#[derive(Debug)]
pub enum ProcessingError {
    MappingError(MappingError),
    SerializationError(SerializationError),
    DataFieldNotFound,
}

#[derive(Debug)]
pub enum SerializationError {
    InvalidFormat,
    SizeMismatch,
}

impl From<MappingError> for ProcessingError {
    fn from(error: MappingError) -> Self {
        ProcessingError::MappingError(error)
    }
}

impl From<SerializationError> for ProcessingError {
    fn from(error: SerializationError) -> Self {
        ProcessingError::SerializationError(error)
    }
}
```

## 5. DSL解析器扩展

### 5.1 新增DSL语法规则

需要扩展DSL解析器以支持新的语法元素：

```rust
// 在DSL解析器中添加新规则
pub enum DslStatement {
    PackageDefinition(PackageDefinition),
    MappingRule(FieldMappingRule),
    HeaderPointerRule(PointerRule),
    BoundaryDetectionRule(BoundaryRule),
}

pub struct DslParser {
    // 现有的解析器字段
}

impl DslParser {
    pub fn parse_package_definition(&self, tokens: &[Token]) -> Result<PackageDefinition, ParseError> {
        // 解析包定义的实现
        unimplemented!()
    }
    
    pub fn parse_mapping_rule(&self, tokens: &[Token]) -> Result<FieldMappingRule, ParseError> {
        // 解析映射规则的实现
        unimplemented!()
    }
    
    pub fn parse_header_pointer_rule(&self, tokens: &[Token]) -> Result<PointerRule, ParseError> {
        // 解析导头指针规则的实现
        unimplemented!()
    }
}

#[derive(Debug, Clone)]
pub struct PointerRule {
    pub pointer_field: String,
    pub target_area: String,
    pub resolution_method: String,
    pub output_field: String,
}

#[derive(Debug, Clone)]
pub struct BoundaryRule {
    pub descriptor_field: String,
    pub data_field: String,
    pub detection_method: String,
    pub output_format: String,
}
```

这个实现方案提供了完整的嵌套包恢复功能，包括独立的字段映射机制和导头指针处理，完全符合连接器模式的设计理念。